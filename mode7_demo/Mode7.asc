// Track script
struct _m7Vector {
  float x, y, z;
};

int kart_sprite;

// filter
bool filter;
int filter_t = 40;

float _ox[2048];
float _oy[2048];
float _zd[2048];

float point_angle, _angle, z_t, dist, z_dist;
int t_x, t_z, t_w;  // texture coords

int precision = 1000000;


void Mode7::SetBgColor(int bg_color)
{
  this._bg_color = bg_color;
  this._empty = DynamicSprite.Create(this._screen_width, this._screen_height, false);
  DrawingSurface* ds = this._empty.GetDrawingSurface();
  ds.Clear(this._bg_color);
  ds.Release();
}

void Mode7::SetSkyColor(int sky_color)
{
  this._sky_color = sky_color;
}

protected void Mode7::_DrawGroundSprites(DrawingSurface* ds, float cam_y, int angle, int ox, int oy)
{  
  float x = -356.0;
  float z = -194.0;
  int sl = 19;
  
  // move track sprite according to camera position
  float sin = Maths.Sin(cam_y);
  float cos = Maths.Cos(cam_y);
  int xx = FloatToInt(x * cos - z * sin, eRoundNearest);
  int zz = FloatToInt(x * sin + z * cos, eRoundNearest);

  DynamicSprite* temp = DynamicSprite.CreateFromExistingSprite(sl);
  if (angle) temp.Rotate(angle);
  xx = ds.Width/2 +  xx - (temp.Width)/2;
  zz = ds.Height/2 + zz - (temp.Height)/2;
  ds.DrawImage(xx, zz, temp.Graphic);
  temp.Delete();
}

protected void Mode7::_GenerateTrackSprite() {   
  // calculate track angle
  this._track_angle = FloatToInt(-this._camera_angle_y, eRoundNearest);
  while (this._track_angle < 0) this._track_angle += 360;
  while (this._track_angle > 359) this._track_angle -= 360;
  
  float cam_y = Maths.DegreesToRadians(IntToFloat(this._track_angle));
  
  this._track_sprite = DynamicSprite.CreateFromExistingSprite(this._track_sprite_slot);
  if (this._track_angle) this._track_sprite.Rotate(this._track_angle);
    
  // sprite offset due to rotation
  int ox = (Game.SpriteWidth[this._track_sprite_slot]  - this._track_sprite.Width)  / 2;
  int oy = (Game.SpriteHeight[this._track_sprite_slot] - this._track_sprite.Height) / 2;
  
  // draw trackobjects
  DrawingSurface* ds = this._track_sprite.GetDrawingSurface();
  this._DrawGroundSprites(ds, cam_y, this._track_angle, ox, oy);
  ds.Release();

  // move track sprite according to camera position
  float sin = Maths.Sin(cam_y);
  float cos = Maths.Cos(cam_y);
  float cox_f = this._camera_position_x * cos - this._camera_position_z * sin;
  float coz_f = this._camera_position_x * sin + this._camera_position_z * cos;
  int cox = FloatToInt(cox_f, eRoundNearest);
  int coz = FloatToInt(coz_f, eRoundNearest);
  
  // final position of rotated track sprite on track canvas
  int x = (this._track_canvas_size/2 - Game.SpriteWidth[this._track_sprite_slot]/2  + ox) - cox;
  int y = (this._track_canvas_size/2 - Game.SpriteHeight[this._track_sprite_slot]/2 + oy) - coz + this._track_canvas_y_offset;
  this._track_sprite.ChangeCanvasSize(this._track_canvas_size, this._track_canvas_size, x, y); 
}


protected void Mode7::_DrawTrack3D() {
  // avoid regenerating if parameters don't change
  if(  this._prev_ground_sprite_slot == this._track_sprite_slot &&
    this._prev_camera_position_x == this._camera_position_x &&
    this._prev_camera_position_y == this._camera_position_y &&
    this._prev_camera_position_z == this._camera_position_z &&
    this._prev_camera_angle_x == this._camera_angle_x &&
    this._prev_camera_angle_y == this._camera_angle_y)
  {
    return;  
  }  

  this._GenerateTrackSprite();
  
  if(this._empty == null) {
    this.SetBgColor(0);
  }
  
  this._ground_3d = DynamicSprite.CreateFromExistingSprite(this._empty.Graphic, false);
  
  DrawingSurface* ds = this._ground_3d.GetDrawingSurface();

  // "skybox"
  ds.DrawingColor = this._sky_color;
  // calculate horizon
  int hor_y = this._screen_y + this._screen_height/2 - FloatToInt(Maths.Tan(Maths.DegreesToRadians(this._camera_angle_x)) * this._camera_dist, eRoundNearest);
  if (hor_y >= 0) {
    ds.DrawRectangle(0, 0, this._screen_width - 1, hor_y - 1);
    int sbx = ((this._track_angle*256)/60) % 256 - 256;
    ds.DrawImage(sbx, hor_y - Game.SpriteHeight[this._horizon_sprite_slot], this._horizon_sprite_slot);
  }

  int y = this._screen_y;
  float y_screen = -IntToFloat(this._screen_height - 1) / 2.0;
  DynamicSprite* t;
  
  // screen width, used for distance calculation
  float s_w = IntToFloat(this._screen_width);
  
  // main loop
  while (y < this._screen_y + this._screen_height) {
    
    // angle between camera's horizon and current scanline
    point_angle = Maths.ArcTan2(y_screen, this._camera_dist);
    // angle between line camera-scanline & ground
    _angle = Maths.DegreesToRadians(this._camera_angle_x) + point_angle;
    // z coordinate of respective ground line
    z_t = this._camera_position_y / Maths.Tan(_angle);
    // distance between camera and ground line
    dist = this._camera_position_y / Maths.Sin(_angle);
    // distance between camera's image plane and ground line, used to shrink scanline
    z_dist = dist * Maths.Cos(point_angle);
    
    // width and x of scan line
    float t_w_f = (s_w * z_dist) / this._camera_dist;
    t_w = FloatToInt(t_w_f, eRoundNearest);
    
    // too far away -> scan line to wide -> grab less, draw centered
    int f = 1;
    int draw_width = this._screen_width + 4; // saw tooth requires wider image
    if (t_w > this._track_canvas_size) {
      f = (precision * t_w) / this._track_canvas_size;
      t_w = this._track_canvas_size;
      t_w_f = IntToFloat(t_w);
      draw_width = (draw_width * precision) / f;
    }
    int draw_x = (this._screen_width - draw_width) / 2;
    
    t_x = (this._track_canvas_size - t_w) / 2;
    // saw tooth correction
    if (t_w % 2) draw_x -= 2;
    
    // calculate y coordinate of line on canvas
    t_z = this._track_canvas_size / 2 - FloatToInt(z_t, eRoundNearest) + this._track_canvas_y_offset;
    bool visible = draw_x > -6 && draw_x < this._screen_width && y > 0 && y < this._screen_height - this._screen_y;
    if (z_t > 0.0 && t_z >= 0 && t_z < this._track_canvas_size && visible) {
      
      DrawingSurface* canvas = this._track_sprite.GetDrawingSurface();
      t = DynamicSprite.CreateFromDrawingSurface(canvas, t_x, t_z, t_w, 1);
      canvas.Release();
      if (filter) {
        ds.DrawImage(draw_x+1, y-1, t.Graphic, filter_t, draw_width-2, 1);
        ds.DrawImage(draw_x-1, y+1, t.Graphic, filter_t, draw_width+2, 1);
      }
      ds.DrawImage(draw_x, y, t.Graphic, 0, draw_width, 1);
    }
    
    y_screen += 1.0;
    y++;
    if (filter) {
      y_screen += 1.0;
      y++;
    }
  }  
  ds.Release();  
  
  this._prev_ground_sprite_slot = this._track_sprite_slot;
  this._prev_camera_position_x = this._camera_position_x;
  this._prev_camera_position_y = this._camera_position_y;
  this._prev_camera_position_z = this._camera_position_z;
  this._prev_camera_angle_x = this._camera_angle_x;
  this._prev_camera_angle_y = this._camera_angle_y;
}


void Mode7World::UpdateObjects() {
  int fnd_objects = 0;
  
  // get object's position relative to camera and check distance
  _m7Vector o;
  for (int i=0; i < this.ObjectCount; i++) {
    o.x = this.Objects[i].X;
    o.z = this.Objects[i].Z;
    this.Objects[i].ScreenVisible = false;
   
    // translate object's x,z to camera's coords
    float cox = o.x - this._camera_position_x;
    float coz = -(o.z - this._camera_position_z);
    
    // rotate by negative camera's y angle
    float sin = Maths.Sin(Maths.DegreesToRadians(this._camera_angle_y));
    float cos = Maths.Cos(Maths.DegreesToRadians(this._camera_angle_y));
    o.x = cox * cos - coz * sin;
    o.z = cox * sin + coz * cos;
    
    // object is in front of camera
    if (o.z > 0.0) {
      
      // angle between line from camera to object and ground
      float obj_angle = Maths.ArcTan2(this._camera_position_y - this.Objects[i].Y, o.z);
      dist = o.z / Maths.Cos(obj_angle);
      // translate x angle to camera
      obj_angle -= Maths.DegreesToRadians(this._camera_angle_x);
      o.y = dist * Maths.Sin(obj_angle);
      z_dist = dist * Maths.Cos(obj_angle);
      
      if (z_dist > 0.1 && z_dist < 1024.0) {
        
        // add object to list
        _ox[fnd_objects] = o.x;
        _oy[fnd_objects] = o.y;
        _zd[fnd_objects] = z_dist;
        this.ObjectScreenVisibleID[fnd_objects] = i;
        
        // init z-buffer  
        this.ObjectScreenVisibleOrder[fnd_objects] = fnd_objects;
        fnd_objects++;
      }
    }
  }
  
  this.ObjectScreenVisibleCount = fnd_objects;
  
  // no object visible?
  if (fnd_objects == 0) return;

  // sort found objects
  if (fnd_objects > 1) {
    // bubble sort   
    for(int i = 0; i < fnd_objects - 1; i++) {
      for (int j = i; j < fnd_objects; j++) {
        if (_zd[this.ObjectScreenVisibleOrder[i]] < _zd[this.ObjectScreenVisibleOrder[j]]) {
          int swap = this.ObjectScreenVisibleOrder[i];
          this.ObjectScreenVisibleOrder[i] = this.ObjectScreenVisibleOrder[j];
          this.ObjectScreenVisibleOrder[j] = swap;
        }
      }
    }
  }

  int in,  obin, slot, w, h; // in: fnd_list index, obin: all objects list index
  int x2d, y2d;
  
  
  for (int i=0; i < this.ObjectScreenVisibleCount; i++) {
    in = this.ObjectScreenVisibleOrder[i];
    obin = this.ObjectScreenVisibleID[in];    

    float f = this._camera_dist / _zd[in];
    float factor = this.Objects[obin].Factor;
    
    slot = this.Objects[obin].Graphic;   
    
    // turn into 2D coords
    x2d = this._screen_x + this._screen_width/2  + FloatToInt(_ox[in] * f, eRoundNearest);
    y2d = this._screen_y + this._screen_height/2 + FloatToInt(_oy[in] * f, eRoundNearest);
    // size
    w = FloatToInt(IntToFloat(Game.SpriteWidth[slot])  * f * factor, eRoundNearest);
    h = FloatToInt(IntToFloat(Game.SpriteHeight[slot]) * f * factor, eRoundNearest);
   
    int obj_d_x = x2d - w/2;
    int obj_d_y = y2d - (h*9/10);
    
    this.Objects[obin].ScreenX = obj_d_x;
    this.Objects[obin].ScreenY = obj_d_y;
    this.Objects[obin].ScreenWidth = w;
    this.Objects[obin].ScreenHeight = h;
    this.Objects[obin].ScreenVisible = true;
    this.Objects[obin].ScreenZOrder = i;    
  }
}

protected void Mode7World::_DrawObjects() {
  // finally, draw sorted objects
  DrawingSurface* ds = this.Screen.GetDrawingSurface();
  
  int in, obin,  slot;  // in: fnd_list index, obin: all objects list index
  for (int i=0; i < this.ObjectScreenVisibleCount; i++) {
    in = this.ObjectScreenVisibleOrder[i];
    obin = this.ObjectScreenVisibleID[in];
    
    slot = this.Objects[obin].Graphic;    
    // kart slot
    if (obin == 0) 
    {
      if (kart_sprite <= 0) {
        slot = 27 - kart_sprite;
      } else {
        slot = 43 - kart_sprite;
      }        
    }
    
    ds.DrawImage(this.Objects[obin].ScreenX, this.Objects[obin].ScreenY,
      slot, 0, this.Objects[obin].ScreenWidth, this.Objects[obin].ScreenHeight);
  }
  
  ds.Release();
}

protected void Mode7::_CameraTrack(eCameraTargetType camType, float target_x, float target_y, float target_z,  float teta_angle) {

  _m7Vector target;
  target.x = target_x;
  target.y = target_y;
  target.z = target_z;  
  
  float camera_angle_target = teta_angle;
  
  // determine kart sprite
  int apart = FloatToInt(camera_angle_target - this._camera_angle_y, eRoundNearest);
  while (apart > 180) apart -= 360;
  while (apart < -180) apart += 360;
  kart_sprite = apart / 22;

  if (camType == eCameraTarget_Behind)
  {
    // set camera behind kart
    float behind = 64.0;
   
    // make it lazy
    this._camera_angle_y += (camera_angle_target - this._camera_angle_y) * 0.05;
    
    float sin = Maths.Sin(Maths.DegreesToRadians(this._camera_angle_y));
    float cos = Maths.Cos(Maths.DegreesToRadians(this._camera_angle_y));
    this._camera_position_x = target.x - behind * sin;
    this._camera_position_z = target.z + behind * cos;
  }
  else if (camType == eCameraTarget_Sides) 
  {
    this._camera_position_x = 100.0;
    this._camera_position_z = 100.0;
    float dx = this._camera_position_x-target.x;
    float dz = this._camera_position_z-target.z;
    this._camera_angle_y = -Maths.RadiansToDegrees(Maths.ArcTan2(dx, dz));
    float target_dist = Maths.Sqrt(dx * dx + dz * dz);
    this._camera_angle_x = Maths.RadiansToDegrees(Maths.ArcTan2(this._camera_position_y, target_dist));
    target_dist = target_dist * 3.0;
    if (target_dist < 100.0) target_dist = 100.0;
    this._camera_dist = target_dist;
    //lblDebug.Text = String.Format("%f", this._camera_angle_x);
  }
}  

void Mode7World::SetObj(int slot, float x, float y, float z)
{
  this.Objects[slot].X = x;
  this.Objects[slot].Y = y;
  this.Objects[slot].Z = z;
}

void Mode7::TargetCamera(float target_x, float target_y, float target_z,  float teta_angle, eCameraTargetType camType) 
{  
  this._CameraTrack(camType, target_x, target_y, target_z, teta_angle);
}


void Mode7::Draw() 
{  
  this._DrawTrack3D();
}

void Mode7World::DrawWorld() 
{  
  this._DrawTrack3D();
  
  this.Screen = DynamicSprite.CreateFromExistingSprite(this._ground_3d.Graphic, false);
  
  this._DrawObjects();
}


void Mode7::SetCamera(float x, float y, float z, float xa, float ya, float focal_length)
{
  this._camera_position_x = x;
  this._camera_position_y = y;
  this._camera_position_z = z;
  this._camera_angle_x = xa;
  this._camera_angle_y = ya;
  this._camera_dist = focal_length;
}

void Mode7World::AddObject(int x, int z, float factor, int slot)
{
  if (this.ObjectCount == MAX_OBJECTS) return;
  this.Objects[this.ObjectCount] = new Obj;
  this.Objects[this.ObjectCount].X = IntToFloat(x);
  this.Objects[this.ObjectCount].Y = 0.0;
  this.Objects[this.ObjectCount].Z = IntToFloat(z);
  this.Objects[this.ObjectCount].Factor = factor;
  this.Objects[this.ObjectCount].Graphic = slot;
  this.ObjectCount++;
}

void Mode7::SetViewscreen(int x, int y, int width, int height) 
{
  this._screen_x = x;
  this._screen_y = y;
  this._screen_width = width;
  this._screen_height = height;
  this._ground_3d = DynamicSprite.Create(this._screen_width, this._screen_height, false);
}

void Mode7::SetGroundSprite(int ground_graphic)
{
  this._track_canvas_size = 1024;
  this._track_canvas_y_offset = 512;  // camera position on track_canvas below center
  
  this._track_sprite_slot = ground_graphic;
}

void Mode7::SetHorizonSprite(int horizon_graphic)
{
  this._horizon_sprite_slot = horizon_graphic; 
}

void Mode7::DebugKeyPress(eKeyCode k)
{
  if (k == eKeyUpArrow   && this._camera_angle_x > -40.0) this._camera_angle_x -= 1.0;
  if (k == eKeyDownArrow && this._camera_angle_x <  55.0) this._camera_angle_x += 1.0;
  if (k == eKeyPlus   && this._camera_dist < 400.0) this._camera_dist += 1.0;
  if (k == eKeyHyphen && this._camera_dist >  10.0) this._camera_dist -= 1.0;
  if (k == eKeyI) this._camera_position_y += 1.0;
  if (k == eKeyK) this._camera_position_y -= 1.0;
  if (k == eKeyO) this._camera_position_x += 1.0;
  if (k == eKeyL) this._camera_position_x -= 1.0;

  // debug
  if (k == eKeyLeftArrow) this._camera_angle_y += 1.0;
  if (k == eKeyRightArrow) this._camera_angle_y -= 1.0;  
}
